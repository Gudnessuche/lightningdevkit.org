(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{348:function(t,e,n){"use strict";n.r(e);var o=n(6),i=Object(o.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"confirmed-transactions"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#confirmed-transactions"}},[t._v("#")]),t._v(" Confirmed Transactions")]),t._v(" "),e("p",[t._v("Up until this point, we've explored how to notify LDK of chain activity using\nblocks. But what if you're sourcing chain activity from a place that doesn't\nprovide a block-centric interface, like Electrum?")]),t._v(" "),e("p",[t._v("LDK's "),e("code",[t._v("ChannelManager")]),t._v(" and "),e("code",[t._v("ChainMonitor")]),t._v(" implement a "),e("code",[t._v("chain::Confirm")]),t._v(" interface to support this\nuse case, analogous to the block-oriented "),e("code",[t._v("chain::Listen")]),t._v(" interface which we've been using up until\nnow. With this alternative approach, you still need to give LDK information about chain activity,\nbut only for transactions of interest. To this end, you must call "),e("code",[t._v("Confirm::transactions_confirmed")]),t._v("\nwhen any transactions identified by "),e("code",[t._v("chain::Filter")]),t._v("'s "),e("code",[t._v("register_tx")]),t._v("/"),e("code",[t._v("register_output")]),t._v(" methods are\nconfirmed.")]),t._v(" "),e("p",[t._v("You also need to notify LDK of any transactions with insufficient confirmations\nthat have been reorganized out of the chain. Transactions that need to be monitored for such\nreorganization are returned by "),e("code",[t._v("Confirm::get_relevant_txids")]),t._v(". If any of these transactions become\nunconfirmed, you must call "),e("code",[t._v("Confirm::transaction_unconfirmed")]),t._v(".")]),t._v(" "),e("p",[t._v("Lastly, you must notify LDK whenever a new chain tip is available using\nthe "),e("code",[t._v("Confirm::best_block_updated")]),t._v(" method. See the documentation for a full\npicture of how this interface is intended to be used.")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),e("p",[t._v("Note that the described methods of "),e("code",[t._v("Confirm")]),t._v(" must be called both on the\n"),e("code",[t._v("ChannelManager")]),t._v(" "),e("em",[t._v("and")]),t._v(" the "),e("code",[t._v("ChainMonitor")]),t._v(".")])]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),e("p",[t._v("Be advised that "),e("code",[t._v("chain::Confirm")]),t._v(" is a less mature interface than\n"),e("code",[t._v("chain::Listen")]),t._v(". As such, there is not yet a utility like\n"),e("code",[t._v("lightning-block-sync")]),t._v(" to use for interacting with clients like Electrum.")])])])}),[],!1,null,null,null);e.default=i.exports}}]);